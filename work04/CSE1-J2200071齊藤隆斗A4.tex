\documentclass[titlepage]{jsarticle}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{ascmac}
\usepackage{bm}
\usepackage{listings}
\theoremstyle{definition}
\title{情報科学実験1 \\ 4. 教育用計算機KUE-CHIP2(基礎編1)}
\author{J2200071 齊藤 隆斗 \\ 実験グループ: A班}
\date{実験実施日: 2024年4月18日 \\ レポート提出日: $\today$ \\ 提出期限: 2024年4月25日}

\begin{document}
\maketitle

\section{実験で作成したプログラムとその説明}

\subsection{ACCの値をIXの値回足す、即ち$ACC \times IX \rightarrow ACC$を行うプログラム}

\subsubsection{プログラム}

\begin{lstlisting}
  ADDR  DATA     OPECODE
   00    75    ST ACC, (03H)
   01    03
   02    C0    EOR ACC, ACC
   03    B5    ADD ACC, (03H)
   04    03
   05    AA    SUB IX, 1
   06    01
   07    31    BNZ 03H
   08    03
   09    0F    HLT
\end{lstlisting}

\subsubsection{説明}
大まかな処理の流れは、入力をACCとIXに格納して、出力をACCに格納するという形になっている.
プログラムのアイディアは、0にACCをIX回足すことによって、ACC $\times$ IX $\rightarrow$ ACC を実現するという発想である.
まず、ACCを、出力の際に使用することになるので、入力として格納したACCのデータをメモリのデータ領域の03Hに退避しておく.
そして、ACCのデータを0に初期化する.その後、ACCに、退避しておいたデータを足したあとにIXの値を1だけ減少させる.
IXの値が0になるまで繰り返すことでこの操作をIX回繰り返すことができる.

\subsection{メモリに格納してある 3 つのデータを加算するプログラム}

\subsubsection{プログラム}

\begin{lstlisting}
  ADDR  DATA     OPECODE
   00    C0    EOR ACC, ACC
   01    B5    ADD ACC, (00H)
   02    00
   03    B5    ADD ACC, (01H)
   04    01
   05    B5    ADD ACC, (02H)
   06    02
   07    0F    HLT
\end{lstlisting}

\subsubsection{説明}
メモリのデータ領域の00H, 01H, 02Hに入力を格納して、出力(足した結果)をACCに格納するという流れとなっている.
ACCに累積和を格納し、それを更新していくというアイディアである.
まず、ACCの値を0に初期化しておく.そして、ACCと00Hに格納したデータを足したものをACCに再び格納する.
そして同じように、操作後のACCと01Hに格納したデータを足したものをACCに格納する.
03Hに対しても同様の操作を行えば、ACCには、3つのデータ領域00H, 01H, 02Hに格納されたデータを足したものが格納されていることになる.


\subsection{1からNまでの整数の加算を行うプログラム}

\subsubsection{プログラム}

\begin{lstlisting}
  ADDR  DATA              OPECODE
   00    6C             LD IX, [80H]
   01    80
   02    62             LD ACC, 0
   03    00
   04    B1    LOOP:    ADD ACC, IX
   05    AA             SUB IX, 1
   06    01
   07    33             BP LOOP
   08    04
   09    74             ST ACC, [81H]
   0A    81
   0B    0F             HLT
\end{lstlisting}

\subsubsection{説明}
メモリのデータ領域の80Hに入力を格納し、81Hに出力を格納するという流れである.
アイディアとしては、ACCにN, N-1,$\ldots$, 2, 1を次々に足していくことで、Nの総和を実現している.
まず、IXにNを格納し、ACCに0を格納し、初期化を行う.
その後、ACCとIXを足したものをACCに格納し、IXの値を1だけ減少させる. IXにはn-1が格納されることになる.
これをIXの値が1以上である間だけ繰り返す. 最後の1をACCに足した後、IXの値は0になるため繰り返しが終了する.
これによって、まずACCにNを足し、その後N-1を足し、$\ldots$、その後2を足し、その後に1を足して処理を終了するという操作を実装している.
この操作を終えた後のACCにはNの総和が格納されており、このACCのデータをメモリのデータ領域の81Hに格納してプログラムを終了する.


\subsection{多倍長の加算を行うプログラム}

\subsubsection{プログラム}

\begin{lstlisting}
  ADDR  DATA              OPECODE
   00    6C             LD IX, [C0H]
   01    C0
   02    20             RCF
   03    66    LOOP:    LD ACC, [IX+7FH]
   04    7F
   05    96             ADC ACC, [IX+8FH]
   06    8F
   07    76             ST ACC, [IX+9FH]
   08    9F
   09    AA             SUB IX, 1
   0A    01
   0B    33             BP LOOP
   0C    03
   0D    0F             HLT
\end{lstlisting}

\subsubsection{説明}
インデックス修飾とキャリーフラグを使用することで、多倍長の加算を実現する.
このプログラム例では4Byte同士の足し算行っているので説明もこの場合について行う.
メモリのプログラム領域のC0に何Byteでの加算を行うかの入力データを、80H, 81H, 82H, 83Hに加算で使用される被演算子の入力データを、
90H, 91H, 92H, 93Hにもう一方の入力データを格納し、これらを足し算した結果をA0H, A1H, A2H, A3Hに格納するという流れである.
ここで、より小さい番地に、演算に使用するデータのより上位のビットが格納されることに注意する.
具体的には、80HをMSB、83HをLSBとして加算を行うということである.
プログラムのアイディアは、まず、データの下位バイトから1Byteずつ足し算を行っていく.
そして、桁が溢れた場合はキャリーフラグを1にセットし、次回の上位ビットの足し算で追加的にこれを足す.
これを繰り返すことによって、データ全体での足し算を実現するというものである.
ここで、プログラムについて見ていく.まず、何バイトの加算を行うかのデータをIXに格納する.
この例では4Byteであるから、IXには4が格納される.そしてキャリーフラグをリセット(0にセット)する.最初の1Byteでは繰り上がりは無関係であるからである.
次に、83HのデータをACCに格納し、ACC $+$ (93Hのデータ) $+$ (キャリーフラグ) の結果をACCに再代入し、ACCのデータを93Hに格納する.
これで、期待する出力の最初の1Byteを得ることができる.
また、この加算を行った際に桁が溢れた場合はキャリーフラグを1に、そうでない場合は0にセットする.
その後、IXの値を1減少させる.この操作が終了したら、82HのデータをACCに格納し、ACC $+$ (92Hのデータ) $+$ (キャリーフラグ) の結果をACCに再代入し、ACCのデータを92Hに格納する.
この操作を繰り返し、IXの値が0になったならば繰り替えしを終了し、プログラムを停止する.繰り返しは、
ACC(80Hのデータ) $+$ (90Hのデータ) $+$ (キャリーフラグ) の加算が終了した直後に停止する.

\subsection{1バイトの乗算を行うプログラム}

\subsubsection{プログラム}

\begin{lstlisting}
  ADDR  DATA              OPECODE
   00    C0             EOR ACC, ACC
   01    74             ST ACC, [82H]
   02    82
   03    74             ST ACC, [83H]
   04    83
   05    74             ST ACC, [F0H]
   06    F0
   07    64             LD ACC, [81H]
   08    81
   09    74             ST ACC, [F1H]
   0A    F1
   0B    6C             LD IX, [80H]
   0C    80
   0D    4A    LOOP:    SRL IX
   0E    35             BNC SKIP
   0F    1D
   10    20             RCF
   11    64             LD ACC, [83H]
   12    83
   13    94             ADC ACC, [F1H]
   14    F1
   15    74             ST ACC, [83H]
   16    83
   17    64             LD ACC, [82H]
   18    82
   19    94             ADC ACC, [F0H]
   1A    F0
   1B    74             ST ACC, [82H]
   1C    82
   1D    FA    SKIP:    CMP IX, 0
   1E    00
   1F    39             BZ FIN
   20    2D
   21    64             LD ACC, [F1H]
   22    F1
   23    41             SLA ACC
   24    74             ST ACC, [F1H]
   25    F1
   26    64             LD ACC, [F0H]
   27    F0
   28    45             RLA ACC
   29    74             ST ACC, [F0H]
   2A    F0
   2B    30             BA LOOP
   2C    0D
   2D    0F    FIN:     HLT
\end{lstlisting}

\subsubsection{説明}
メモリのプログラム領域の80H, 81Hに入力データ(乗算の被演算子)が格納されて、出力データ(乗算の結果)を82H, 83Hの2Byteに格納されるという流れである.
この出力データについても、より小さい番地にデータのより上位のビットが格納されることに注意する.
このプログラムのアイディアは、乗算の筆算を2進数で行うというところにある.
例として、$1001 \times 1010$について考える.
\begin{equation*}
	\begin{split}
		1001 \times 1010 &= (1 \times 1000 + 0 \times 100 + 0 \times 10 + 1 \times 1) \times 1010 \\
		&= 1 \times 1010 \times 1000 + 0 \times 1010 \times 100 + 0 \times 1010 \times 10 + 1 \times 1010 \times 1 \\
		&= 1 \times 1010000 + 0 \times 101000 + 0 \times 10100 + 1 \times 1010
	\end{split}
\end{equation*}
となる.これを見ると、1001の1が立っている桁それぞれについて、それに対応する左シフトを1010に対して行ってそれを足していくことで掛け算を実装することができる.
ここでプログラムについて見ていく.まず、メモリのプログラム領域の82H, 83H, F0を0に、そして81HのデータをF1に格納し、80HのデータをIXに格納し、初期化する.
そして次の処理をプログラムが停止するまでくりかえす. \\
まず、IXに対してSRLを行って、1桁目の値が溢れてキャリーフラグがセットされる.その後、BNCによって1桁目が0か1かを調べる.
これは出力に対して加算を行う必要があるのかを判定するのに必要である.\\
($\mathrm{i}$)キャリーフラグが0であったとき
出力に対して加算は行わないので、次の桁の加算に備えてF0H, F1Hを左にシフトしておく.
しかし、この時点ですべての桁が0であったらこれ以降加算は行わないということなのでループを抜けてプログラムを停止することに注意する.
左シフトを行うために、まず、F1HをSLAによって左シフトを行う.このときに溢れた桁はキャリーフラグとして保存される.
次にF0HをRLAによって左シフトする.このときにシフトされたF0Hの1桁目に先程保存したキャリーフラグを割り当てる.
これによって、全体として左シフトを行うことができる. \\
($\mathrm{ii}$)キャリーフラグが1であったとき
出力に対して加算を行う必要がある.この時点でシフトを行う必要はない.
なぜならば1回目の繰り返しではそもそも1桁目についての加算を行えば良いのでシフトを必要としない.
2回目以降の繰り返しでは、すでに1回目の繰り返しによって、シフトが行われているからである.
よって、素直に出力とシフトされたデータの加算を行えば良い.まず、83HのデータとF1Hのデータを加算する.
このときに桁が溢れた場合、キャリーフラグが1にセットされる.
次に82HとF0Hのデータの加算を行う.このとき、先程のキャリーフラグも加算されることに注意する.
これで加算は終了したので、この次の繰り返しに向けてシフトを行う必要がある.
これは($\mathrm{i}$)と同様に行えば良い.

\section{考察課題}

\subsection*{2. 例題の乗算プログラムを参考にして、1バイトの除算プログラムを作成し、解説せよ.}

\subsubsection{プログラム}

\begin{lstlisting}
  ADDR  DATA     OPECODE
   00    75    ST ACC, (03H)
   01    03
   02    C0    EOR ACC, ACC
   03    A2    SUB ACC, 1
   04    01
   05    B2    ADD ACC, 1
   06    01
   07    AD    SUB IX, (03H)
   08    03
   09    32    BZP 05H
   0A    05
   0B    BD    ADD IX, (03H)
   0C    03
   0D    0F    HLT

\end{lstlisting}

\subsubsection{説明}
IX $\div$ ACC $\rightarrow$ ACC $\cdots$ IXを行うプログラムを実装した.
プログラムの大まかな流れは、ACCに被除数、IXに除数を入力して、ACCに商、IXに余りを出力する.
プログラムのアイディアは被除数から除数を何回だけ引くことができるのかということに注目することで商を求め、
余りは被除数からその商だけ除数を引いたときの数のことであると見ることである.
プログラムについて見ていくと、まず、ACCに格納した除数をメモリのデータ領域に退避させておき、ACCを0にセットする.
その後ACCの値から1を引くことでACCを-1にセットする.
そして、その後1を加えてACCを0にする.
これは繰り返しの際にSUBという命令でフラグの状態を利用したいからである.
そして、IXから、除数を引いて、まだ負でないならACCの値を1増加させて、IXから除数を再び引く.負でないなら, $\ldots$ というようにこの操作を繰り返す.
IXが負になったら、その(ACCに格納された値+1) $\times$ (除数) $>$ (被除数) となってしまうので繰り返しを停止する.
繰り返し後にIXにメモリ領域の03Hのデータを足しているのはそのままだと余分に1回だけ引かれてしまっているのでもう一度IXを足して正しい余りを出力するためである.

\subsection*{4. SBC命令の動作について説明し、それを用いて多倍長の引き算プログラムを作成せよ.ただし、計算結果が負になる場合は考えなくても良い.}

\subsubsection{プログラム}

\begin{lstlisting}
  ADDR  DATA              OPECODE
   00    6C             LD IX, [C0H]
   01    C0
   02    20             RCF
   03    66    LOOP:    LD ACC, [IX+7FH]
   04    7F
   05    86             SBC ACC, [IX+8FH]
   06    8F
   07    76             ST ACC, [IX+9FH]
   08    9F
   09    AA             SUB IX, 1
   0A    01
   0B    33             BP LOOP
   0C    03
   0D    0F             HLT
\end{lstlisting}

\subsubsection{SBC命令の説明}
SBC命令は、SBC A B のとき、 (A) $-$ (B) $-$ CF $\rightarrow$ A を行う.
このとき、ボローが発生したときにCFが立つ.
ここで、ボローとは存在しない桁からの繰り下がりを意味している.
上の処理を見てわかるように、このCFがSBC命令の減算にも影響が及ぶ.
この機能を利用して引き算における繰り下がりを実装する.

\subsubsection{プログラムの説明}
プログラムの流れとしては、何バイトのデータを減算するかのデータと実際に減算をする際に使用するデータを入力として受け取り、減算した結果を出力する.
プログラムのアイディアとしては、大まかにはデータの下位バイトから減算を行っていき、
SBCを利用して、ボローが発生した場合に次回の上位バイトの減算の際に被減数から1を引くことで繰り下がりを実装している.
ここでプログラムについて見ていく.
まず何バイトの引き算を行うかのデータを入力する.その後キャリーフラグを0にセットする.
これは最初の1バイトの引き算では下位バイトからの繰り下がりは考慮しなくても良いからである.
この後次の操作を繰り返す.
ACCに被減数のデータの対応するバイトをACCに格納する.IXの値が繰り返しの度に1つずつ減っていくので格納するデータも繰り返しの度に下位バイトから上位バイトへとズレていく.
次にACCの値から減数のデータの対応するバイトを減算する.被減数のデータも同様に下位バイトから上位バイトへとズレていく.
このとき1回目の繰り返しの場合、キャリーフラグはリセットされているが2回目以降は繰り下がりが発生していた場合、直前のバイトの繰り下がりも考慮して更に1を引く必要がある.
この減算の際、(被減数-CF)よりも減数の方が大きい場合、繰り下がりが発生するためボローが発生する.
よって、CFに1がセットされる.これは次の繰り返しの際に次の減数のバイトから1を引くかどうかに影響を与える.
この後、出力データとしてACCの値が格納され、IXから1が引かれる.IXが正である間は繰り返しこの処理を繰り返す.
即ち、IXが1であるときは処理を実行するので80Hと90Hを減算のデータとして利用し、出力をA0Hに格納するため期待通りの繰り返しの挙動となっている.
結果として、Nバイトのとき、A0H, $\ldots$, (N-1)+A0H に減算の結果が出力される.

\end{document}
